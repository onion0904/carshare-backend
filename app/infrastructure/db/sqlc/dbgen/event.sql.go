// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: event.sql

package sqlc

import (
	"context"
	"time"
)

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM events
WHERE id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, eventid string) error {
	_, err := q.db.ExecContext(ctx, deleteEvent, eventid)
	return err
}

const findDayOfEvent = `-- name: FindDayOfEvent :one
SELECT id, user_id, item_id, together, description, year, month, day, date, start_date, end_date, important, created_at, updated_at
FROM events
WHERE year  = $1
    AND month = $2
    AND day = $3
`

type FindDayOfEventParams struct {
	Year  int32
	Month int32
	Day   int32
}

func (q *Queries) FindDayOfEvent(ctx context.Context, arg FindDayOfEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, findDayOfEvent, arg.Year, arg.Month, arg.Day)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.Together,
		&i.Description,
		&i.Year,
		&i.Month,
		&i.Day,
		&i.Date,
		&i.StartDate,
		&i.EndDate,
		&i.Important,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findEvent = `-- name: FindEvent :one
SELECT id, user_id, item_id, together, description, year, month, day, date, start_date, end_date, important, created_at, updated_at
FROM events
WHERE id = $1
`

func (q *Queries) FindEvent(ctx context.Context, eventid string) (Event, error) {
	row := q.db.QueryRowContext(ctx, findEvent, eventid)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.Together,
		&i.Description,
		&i.Year,
		&i.Month,
		&i.Day,
		&i.Date,
		&i.StartDate,
		&i.EndDate,
		&i.Important,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findMonthEventIDs = `-- name: FindMonthEventIDs :many
SELECT id
FROM events
WHERE year  = $1
    AND month = $2
`

type FindMonthEventIDsParams struct {
	Year  int32
	Month int32
}

func (q *Queries) FindMonthEventIDs(ctx context.Context, arg FindMonthEventIDsParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, findMonthEventIDs, arg.Year, arg.Month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertEvent = `-- name: UpsertEvent :exec
INSERT INTO events (
    id,
    user_id,
    together,
    description,
    year,
    month,
    day,
    date,
    start_date,
    end_date,
    created_at,
    updated_at,
    important
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    NOW(),
    NOW(),
    $11
)
ON CONFLICT (id) DO UPDATE
SET
    user_id     = EXCLUDED.user_id,
    together    = EXCLUDED.together,
    description = EXCLUDED.description,
    year        = EXCLUDED.year,
    month       = EXCLUDED.month,
    day         = EXCLUDED.day,
    date        = EXCLUDED.date,
    start_date  = EXCLUDED.start_date,
    end_date    = EXCLUDED.end_date,
    updated_at  = NOW(),
    important   = EXCLUDED.important
`

type UpsertEventParams struct {
	ID          string
	UserID      string
	Together    bool
	Description string
	Year        int32
	Month       int32
	Day         int32
	Date        time.Time
	StartDate   time.Time
	EndDate     time.Time
	Important   bool
}

func (q *Queries) UpsertEvent(ctx context.Context, arg UpsertEventParams) error {
	_, err := q.db.ExecContext(ctx, upsertEvent,
		arg.ID,
		arg.UserID,
		arg.Together,
		arg.Description,
		arg.Year,
		arg.Month,
		arg.Day,
		arg.Date,
		arg.StartDate,
		arg.EndDate,
		arg.Important,
	)
	return err
}
