// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: event.sql

package sqlc

import (
	"context"
	"time"
)

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM events
WHERE id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, eventid string) error {
	_, err := q.db.ExecContext(ctx, deleteEvent, eventid)
	return err
}

const findDayEvent = `-- name: FindDayEvent :one
SELECT e.id, e.user_id, e.item_id, e.together, e.description, e.year, e.month, e.day, e.date, e.start_date, e.end_date, e.important, e.created_at, e.updated_at
FROM events e
INNER JOIN group_events ge
ON e.id = ge.event_id
WHERE e.year = $1
    AND e.month = $2
    AND e.day = $3
    And ge.group_id = $4
`

type FindDayEventParams struct {
	Year    int32
	Month   int32
	Day     int32
	Groupid string
}

func (q *Queries) FindDayEvent(ctx context.Context, arg FindDayEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, findDayEvent,
		arg.Year,
		arg.Month,
		arg.Day,
		arg.Groupid,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.Together,
		&i.Description,
		&i.Year,
		&i.Month,
		&i.Day,
		&i.Date,
		&i.StartDate,
		&i.EndDate,
		&i.Important,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findDayEvents = `-- name: FindDayEvents :many
SELECT id, user_id, item_id, together, description, year, month, day, date, start_date, end_date, important, created_at, updated_at
FROM events
WHERE year  = $1
    AND month = $2
    AND day = $3
`

type FindDayEventsParams struct {
	Year  int32
	Month int32
	Day   int32
}

func (q *Queries) FindDayEvents(ctx context.Context, arg FindDayEventsParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, findDayEvents, arg.Year, arg.Month, arg.Day)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ItemID,
			&i.Together,
			&i.Description,
			&i.Year,
			&i.Month,
			&i.Day,
			&i.Date,
			&i.StartDate,
			&i.EndDate,
			&i.Important,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findEvent = `-- name: FindEvent :one
SELECT id, user_id, item_id, together, description, year, month, day, date, start_date, end_date, important, created_at, updated_at
FROM events
WHERE id = $1
`

func (q *Queries) FindEvent(ctx context.Context, eventid string) (Event, error) {
	row := q.db.QueryRowContext(ctx, findEvent, eventid)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.Together,
		&i.Description,
		&i.Year,
		&i.Month,
		&i.Day,
		&i.Date,
		&i.StartDate,
		&i.EndDate,
		&i.Important,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findMonthEvents = `-- name: FindMonthEvents :many
SELECT e.id, e.user_id, e.item_id, e.together, e.description, e.year, e.month, e.day, e.date, e.start_date, e.end_date, e.important, e.created_at, e.updated_at
FROM events e
INNER JOIN group_events ge
ON e.id = ge.event_id
WHERE e.year = $1
    AND e.month = $2
    And ge.group_id = $3
`

type FindMonthEventsParams struct {
	Year    int32
	Month   int32
	Groupid string
}

func (q *Queries) FindMonthEvents(ctx context.Context, arg FindMonthEventsParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, findMonthEvents, arg.Year, arg.Month, arg.Groupid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ItemID,
			&i.Together,
			&i.Description,
			&i.Year,
			&i.Month,
			&i.Day,
			&i.Date,
			&i.StartDate,
			&i.EndDate,
			&i.Important,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertEvent = `-- name: UpsertEvent :exec
INSERT INTO events (
    id,
    user_id,
    together,
    description,
    year,
    month,
    day,
    date,
    start_date,
    end_date,
    created_at,
    updated_at,
    important
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    NOW(),
    NOW(),
    $11
)
ON CONFLICT (id) DO UPDATE
SET
    user_id     = EXCLUDED.user_id,
    together    = EXCLUDED.together,
    description = EXCLUDED.description,
    year        = EXCLUDED.year,
    month       = EXCLUDED.month,
    day         = EXCLUDED.day,
    date        = EXCLUDED.date,
    start_date  = EXCLUDED.start_date,
    end_date    = EXCLUDED.end_date,
    updated_at  = NOW(),
    important   = EXCLUDED.important
`

type UpsertEventParams struct {
	ID          string
	UserID      string
	Together    bool
	Description string
	Year        int32
	Month       int32
	Day         int32
	Date        time.Time
	StartDate   time.Time
	EndDate     time.Time
	Important   bool
}

func (q *Queries) UpsertEvent(ctx context.Context, arg UpsertEventParams) error {
	_, err := q.db.ExecContext(ctx, upsertEvent,
		arg.ID,
		arg.UserID,
		arg.Together,
		arg.Description,
		arg.Year,
		arg.Month,
		arg.Day,
		arg.Date,
		arg.StartDate,
		arg.EndDate,
		arg.Important,
	)
	return err
}
