// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: eventRule.sql

package sqlc

import (
	"context"
)

const getEventRuleByUserAndItem = `-- name: GetEventRuleByUserAndItem :one
SELECT
    normal_limit,
    important_limit
FROM event_rules
WHERE user_id = $1
  AND item_id = $2
`

type GetEventRuleByUserAndItemParams struct {
	UserID string
	ItemID string
}

type GetEventRuleByUserAndItemRow struct {
	NormalLimit    int32
	ImportantLimit int32
}

// userIDとitemIDからeventRuleの取得
func (q *Queries) GetEventRuleByUserAndItem(ctx context.Context, arg GetEventRuleByUserAndItemParams) (GetEventRuleByUserAndItemRow, error) {
	row := q.db.QueryRowContext(ctx, getEventRuleByUserAndItem, arg.UserID, arg.ItemID)
	var i GetEventRuleByUserAndItemRow
	err := row.Scan(&i.NormalLimit, &i.ImportantLimit)
	return i, err
}

const getEventRulesByItemID = `-- name: GetEventRulesByItemID :many
SELECT user_id, item_id, normal_limit, important_limit
FROM event_rules
WHERE item_id = $1
ORDER BY user_id
`

func (q *Queries) GetEventRulesByItemID(ctx context.Context, itemID string) ([]EventRule, error) {
	rows, err := q.db.QueryContext(ctx, getEventRulesByItemID, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventRule
	for rows.Next() {
		var i EventRule
		if err := rows.Scan(
			&i.UserID,
			&i.ItemID,
			&i.NormalLimit,
			&i.ImportantLimit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertEventRule = `-- name: UpsertEventRule :exec
INSERT INTO event_rules (
    user_id,
    item_id,
    normal_limit,
    important_limit
)
VALUES (
    $1,
    $2,
    $3,
    $4
)
ON CONFLICT (user_id, item_id) DO UPDATE
SET
    normal_limit = EXCLUDED.normal_limit,
    important_limit = EXCLUDED.important_limit
`

type UpsertEventRuleParams struct {
	UserID         string
	ItemID         string
	NormalLimit    int32
	ImportantLimit int32
}

// eventRuleの追加と更新
func (q *Queries) UpsertEventRule(ctx context.Context, arg UpsertEventRuleParams) error {
	_, err := q.db.ExecContext(ctx, upsertEventRule,
		arg.UserID,
		arg.ItemID,
		arg.NormalLimit,
		arg.ImportantLimit,
	)
	return err
}
